module towwin (clk, reset, win2, win1, hex2, hex1);
	input  logic 		 clk, reset;
	input  logic       win2, win1;
	
	output logic [6:0] hex2, hex1;
	
	logic [2:0] score2, score1; // output?
	
	
	
	
	
	// Standby, and Player 2 and Player 1 victory states
	enum { WAIT, P1, P2 } ps, ns;
	
	// Player score counts
//	integer ct2, ct1;
	logic [2:0] ct2, ct1;
	
	assign score2 = ct2; // or just increment score2 and score1?
	assign score1 = ct1;
	
	// 
	seg7 d2 (.bcd(score2), .leds(hex2));
	seg7 d1 (.bcd(score1), .leds(hex1));

//		initial begin
//			ct2 = 3'b00;
//			ct1 = 3'b00;
//		end
	
	always_comb begin

		
		case (ps)
			WAIT: begin
				if (win2) begin     // if p2 wins a game and they still have less than 7...
					if (ct2 < 7) begin
						ct2 = ct2 + 1'b1;
						ct1 = ct1;         // ??? ct1;
						ns = WAIT;
					end else begin   // P2 has won
						ct2 = ct2;
						ct1 = ct1;
						ns = P2;
					end
				end else if (win1) begin
					if (ct1 < 7) begin
						ct2 = ct2;
						ct1 = ct1 + 1'b1;
						ns = WAIT;
					end else begin   // P1 has won
						ct2 = ct2;
						ct1 = ct1;
						ns = P1;
					end
				end else begin   // Standby
					ct1 = ct1;
					ct2 = ct2;
					ns = WAIT;
				end
			end
			P1: begin
				ct2 = ct2;
				ct1 = ct1;
				ns = P1;
			end
			P2: begin
				ct2 = ct2;
				ct1 = ct1;
				ns = P1;
			end
//			default: leds = ~(7'bX); // Don't Cares
		endcase
		
		
	end
		
	// DFFs
	// !!! This means: only execute when you see a posedge of clk
	always_ff @(posedge clk)
		if (reset)
			ps <= WAIT;  // at reset, go back to None
		else
			ps <= ns; // otherwise, go to the next state, dictated by NS logic
	
endmodule

module towwin_testbench();
	logic clk, reset, win2, win1;
	logic [6:0] leds1, leds2;
	
	towwin dut (clk, reset, win2, win1, leds1, leds2);
	
	// Set up the clock.
	parameter CLOCK_PERIOD=100;
	initial begin
		clk <= 0;
		forever #(CLOCK_PERIOD/2) clk <= ~clk;
	end
	
	// Set up the inputs to the design. Each line is a clock cycle.
	initial begin
								  @(posedge clk);		// !!! you wait for a posedge (and thus FSM)
	reset <= 1; 			  @(posedge clk);		// moves to the next state) before applying
	reset <= 0;            @(posedge clk);		// new inputs
								  @(posedge clk);
	win2 <= 0; win1 <= 0;  @(posedge clk);
								  @(posedge clk);
								  @(posedge clk);
								  @(posedge clk);
								  @(posedge clk);
	win1 <= 1;				  @(posedge clk);
	reset <= 1;	win1 <= 0;			  @(posedge clk);
	reset <= 0;								  @(posedge clk);
							  @(posedge clk);
								  @(posedge clk);
	$stop; // End the simulation.
	end
endmodule