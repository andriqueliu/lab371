// Andrique Liu

// FSM: operates the center light
// Reset: normalLight turns OFF
module normalLight (clk, reset, L, R, NL, NR, lightOn);
	input logic clk, reset;
	
	// L is true when left key is pressed, R is true when the right key
	// is pressed, NL is true when the light on the left is on, and NR
	// is true when the light on the right is on.
	input logic L, R, NL, NR;
	
	// when lightOn is true, the center light should be on.
	output logic lightOn;
	
	// State variables.
	// None, Present
//	enum { DEFON, LON, RON, NONE } ps, ns;
	enum { ON, OFF } ps, ns;

	// Next State logic
//	always_comb begin
//		case (ps)
//			N: if (in) ns = P;
//				else ns = N;
//			P: if (in) ns = P;
//				else ns = N;
//		endcase
//	end
	
	// Next State Logic
	always_comb begin
		case (ps)
			ON: begin
				if (L ^ R) ns = OFF; // ??? conditional syntax? maybe XOR?
				else ns = ON;
			end
			OFF: begin
				if ((R & NL) | (L & NR)) ns = ON;
				else ns = OFF;
			end
		endcase
	end
	
	// Output logic - could also be another always, or part of above block.
	// When ns is ON, output is TRUE
	assign out = {ns == ON};
	
	// Good...
	// assign out to when the next state is On
	
	// DFFs
	// !!! This means: only execute when you see a posedge of clk
	always_ff @(posedge clk)
		if (reset)
			ps <= ON;  // at reset, go back to ON (it's a centerLight)
		else
			ps <= ns; // otherwise, go to the next state, dictated by NS logic

endmodule

// To simulate, you not only have to provide the inputs, but you also
// have to specify the clock, hence the testbench
module centerLight_testbench();
	logic clk, reset;
	logic L, R, NL, NR;
	logic lightOn;
	
	centerLight dut (clk, reset, L, R, NL, NR, lightOn);
	
	// Set up the clock.
	parameter CLOCK_PERIOD=100;
	initial begin
		clk <= 0;
		forever #(CLOCK_PERIOD/2) clk <= ~clk;
	end
	
	// Set up the inputs to the design. Each line is a clock cycle.
	initial begin
								  @(posedge clk);		// !!! you wait for a posedge (and thus FSM)
	reset <= 1; 			  @(posedge clk);		// moves to the next state) before applying
	reset <= 0;            @(posedge clk);		// new inputs
								  @(posedge clk);
								  @(posedge clk);
								  @(posedge clk);
	NL = 0; NR = 0; L = 0; R = 0;
								  @(posedge clk);
	L = 1; NL = 1;  		  @(posedge clk);
								  @(posedge clk);
								  @(posedge clk);
								  @(posedge clk);
	L = 1; NL = 0;			  @(posedge clk);
								  @(posedge clk);
								  @(posedge clk);
								  @(posedge clk);
	R = 1; NL = 1;			  @(posedge clk);
								  @(posedge clk);
								  @(posedge clk);
								  @(posedge clk);
	R = 1; NL = 0;			  @(posedge clk);
								  @(posedge clk);
								  @(posedge clk);
	$stop; // End the simulation.
	end
endmodule